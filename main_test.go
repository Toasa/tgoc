package main

import (
	"os/exec"
	"testing"
	"tgoc/lexer"
	"tgoc/parser"
	"tgoc/x86"
)

func TestCompile(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"0;", "0"},
		// {"20", "20"},
		// {"255", "255"},

		// {"5 + 3;", "8"},
		// {"5 - 3;", "2"},
		// {"5 * 3;", "15"},
		// {"15 / 3;", "5"},
		// {"15 % 3;", "0"},

		// {"5 + 3 + 10;", "18"},
		// {"5 - 3 + 10", "12"},
		// {"2 * 3 + 4", "10"},
		// {"2 + 3 * 4", "14"},
		// {"2 * 3 + 4 * 5;", "26"},
		// {"2 + 3 * 4 + 5", "19"},
		// {"6 / 3 * 10", "20"},
		// {"12 / 4 + 5", "8"},
		// {"6 + 30 / 10", "9"},

		// {"(2 + 3) * 4", "20"},
		// {"(2 + 3) * (4 + 5)", "45"},
		// {"26 / (10 + 3)", "2"},

		// {"a := 20 * 2; a", "40"},
		// {"abc := 30 + 4 * 2; xyz := abc * 2; xyz;", "76"},
		// {"a := 1; b := 1; c := a + b; d := b + c; e := c + d; e;", "5"},
		// {"a := 1; b := 1; c := a + b; d := b + c; e := c + d; return e;", "5"},
		// {"a := 10; a = 1 + 10; return a;", "11"},
		// {"a := 10; a = a + 10; return a;", "20"},
		// {"a := 5; b := a * a; b = 10 + b; return b", "35"},

		// {"a := 2 * 3; b := a + 40;", "46"},

		// {"+10", "10"},
		// {"-2 + 6;", "4"},
		// {"-(10 - 16)", "6"},
		// {"-3*+5*-2", "30"},
		// {"a := -20; return -a;", "20"},

		// {"1 << 7", "128"},
		// {"1024 >> 3", "128"},

		// {"20 == 20", "1"},
		// {"20 != 20", "0"},
		// {"1 + 2 + 3 == 1 * 2 * 3", "1"},
		// {"0 == 1", "0"},
		// {"4 / 2 != 2", "0"},
		// {"4 / 2 == 2", "1"},
		// {"a:=10; a!=11;", "1"},

		// {"true;", "1"},
		// {"false;", "0"},
		// {"1; return false;", "0"},

		// {"1 < 20;", "1"},
		// {"20 < 20", "0"},
		// {"20 < 1", "0"},
		// {"1 > 20;", "0"},
		// {"20 > 1", "1"},

		// {"4 <= 2", "0"},
		// {"10 <= 10", "1"},
		// {"5 >= 10", "0"},

		// {"1 || 0", "1"},
		// {"(1 < 20) || false", "1"},
		// {"true || 1", "1"},
		// {"1 && 0", "0"},
		// {"(1 < 20) && false", "0"},
		// {"true && 1", "1"},

		// {"!0", "1"},
		// {"!1", "0"},
		// {"!true", "0"},
		// {"!false", "1"},
		// {"!(20 >= 10*3)", "1"},

		// {"if true {20;}", "20"},
		// {"if (1 * 3 <= 2 + 4) {return 10;}", "10"},
		// {"if (1*3<=2+4) { return 10; } return 20;", "11"},
		// {"if 1 * 3 <= 2 + 4 { return 20; } else { return 30; }", "20"},
		// {"if false { return 20; } else { return 30; }", "30"},

		// {"6 & 10", "2"},
		// {"6 | 10", "14"},
		// {"6 ^ 10", "12"},
		// {"6 &^ 10", "4"},
		// {"10 &^ 6", "8"},
		// {"30 | 20 & 10", "30"},
		// {"30 & 20 | 10", "30"},

		// {"a := 1; a = 2 * a; a = 2 * a; a = 2 * a; a = 2 * a; a;", "16"},
		{"i := 1; for i < 200 { i = i + 2; } i;", "201"},
		// {"a := 1; for a < 100 { a = a * 2; } a;", "128"},
		// {"i := 1; a := 10 for i < 10 { a = a + i; i = i + 1;} a;", "55"},

		// {"a := 10; for i := 0; i < 10; i = i + 1 { a = a + 1; } return a;", "20"},
	}

	for _, test := range tests {
		l := lexer.New(test.input + "\000")
		l.Analyze()

		p := parser.New(l.Tokens)
		stmts := p.Parse()

		x86.Gen(stmts, len(p.VarMap))

		// err := exec.Command("gcc", "-o", "main.o", "main.s").Run()
		// if err != nil {
		// 	panic(err)
		// }

		// out, _ := exec.Command("./main.o").Output()
		// if err != nil {
		// 	panic(err)
		// }

		// output := string(out[:len(out)-1])

		// if output != test.expected {
		// 	t.Fatalf("expected %s, but got %s\n", test.expected, output)
		// }
		exec.Command("rm", "main.o", "main.s").Run()
	}
}
